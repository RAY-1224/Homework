# 41343114

作業一

## 解題說明

Problem1:本題要求實作阿克曼函數分別為遞迴跟非遞迴。

### 解題策略

Problem1:

遞迴版:

1.每次呼叫 A(m, n) 會再呼叫自己：
若 m = 0 → 直接回傳 n + 1

若 n = 0 → 呼叫 A(m – 1, 1)

其他情況 → 呼叫 A(m – 1, A(m, n – 1))

重點:內層A(m, n – 1)要先算，再代回外層計算。

2. 終止條件:
當 m = 0 時停止。

非遞迴版:

1.用一個 stack <int> 來代替系統的呼叫堆疊。

2.每次遞迴時，把 m「暫存」進堆疊裡。

3.每次返回時，再把它拿出來（pop）

## 程式實作

以下為主要程式碼：


-------------------------------

## 效能分析
Problem1:
1. 時間複雜度：T(m,n)≫O(2n),O(n!),O(nn)。
2. 空間複雜度：空間複雜度為 S(m,n)=O(depth of recursion)。

## 測試與驗證

### 測試案例

| 測試案例 | 輸入參數 $(m,n)$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $(0,1)$      | 2        | 2        |
| 測試二   | $(0,2)$      | 3        | 3        |
| 測試三   | $(2,1)$      | 5        | 5        |
| 測試四   | $(3,6)$      | 509       | 509       |
| 測試五   | $(4,9)$     | 異常拋出 | 異常拋出 |

### 編譯與執行指令

```shell
Ackermann A(m,n) 請輸入 m n(建議 m<=3,n<=6): 2 1
[Recursive]   A(2,1)=5
[Nonrecuresive] A(2,1)=5
```

### 結論

1. 程式能正確計算 $n$ 到 $1$ 的連加總和。  
2. 在 $n < 0$ 的情況下，程式會成功拋出異常，符合設計預期。  
3. 測試案例涵蓋了多種邊界情況（$n = 0$、$n = 1$、$n > 1$、$n < 0$），驗證程式的正確性。

## 申論及開發報告

### 選擇遞迴的原因

在本程式中，使用遞迴來計算連加總和的主要原因如下：

Problem 1 — Ackermann’s Function
1. **函數本身定義就是遞迴形式**  
   本質上就是一個函數呼叫自身，因此最自然的實作方式就是遞迴

2. **容易對應數學定義**  
   用 if–else 結構即可完整反映三種情況，
可直觀展示「遞迴的結構思考」與「終止條件」的概念。

4. **遞迴的語意清楚**  
   在程式中，每次遞迴呼叫都代表一個「子問題的解」，而最終遞迴的返回結果會逐層相加，完成整體問題的求解。  
   這種設計簡化了邏輯，不需要額外變數來維護中間狀態。

透過遞迴實作 Sigma 計算，程式邏輯簡單且易於理解，特別適合展示遞迴的核心思想。然而，遞迴會因堆疊深度受到限制，當 $n$ 值過大時，應考慮使用迭代版本來避免 Stack Overflow 問題。

---------------------------------------------------------------
## 解題說明

Problem2:本題目要求實作冪集

### 解題策略

Problem2:

1.對第 index 個元素做二擇一：不選 / 選；用遞迴展開到尾（index==n）就輸出。

2.用固定陣列裝元素與選取狀態。

## 程式實作

以下為主要程式碼：

Problem2:
```cpp
#include <iostream>
#include <string>
using namespace std;

void PowerSetRecursive(string S[], int n, int index, bool chosen[]) {
    if (index == n) {
        cout << "{";
        bool first = true;
        for (int i = 0; i < n; ++i) {
            if (chosen[i]) {
                if (!first) cout << ", ";
                cout << S[i];
                first = false;
            }
        }
        cout << "}\n";
        return;
    }
    // 不選 S[index]
    chosen[index] = false;
    PowerSetRecursive(S, n, index + 1, chosen);
    // 選 S[index]
    chosen[index] = true;
    PowerSetRecursive(S, n, index + 1, chosen);
}

int main() {
    int n;
    cout << "Powerset：請輸入元素個數 n：";
    if (!(cin >> n) || n <= 0 || n > 30) return 0;

    string S[30];
    bool chosen[30];
    for (int i = 0; i < n; ++i) chosen[i] = false;

    cout << "請輸入 " << n << " 個元素（空白分隔）：";
    for (int i = 0; i < n; ++i) cin >> S[i];

    cout << "\n所有子集合（共 2^" << n << " 個）：\n";
    PowerSetRecursive(S, n, 0, chosen);
    return 0;
}


```
## 效能分析

Problem2:  
1. 時間複雜度：T(n)=O(n×2n)。
2. 空間複雜度：空間複雜度為S(n)=O(n)。

## 測試與驗證

### 測試案例

| 測試案例 | 元素數 n  | 輸入內容    | 實際數量輸出 |
|----------|--------------|----------|----------|
| 測試一   | $n = 1$      |    a    |    2     |
| 測試二   | $n = 2$      |     AＢ   |    4     |
| 測試三   | $n = 3$      |      １　２　３   |    8     |
| 測試四   | $n = 5$      |    Ａ B c d e   |    32    |
| 測試五   | $n = 25$     | 異常拋出 | 異常拋出 |

### 編譯與執行指令

```shell
輸入元素個數:1
輸入1個元素(空白分隔)a

所有子集合(2^1):
{}
{a}
```

### 結論

1. 程式能正確計算 $n$ 到 $1$ 的連加總和。  
2. 在 $n < 0$ 的情況下，程式會成功拋出異常，符合設計預期。  
3. 測試案例涵蓋了多種邊界情況（$n = 0$、$n = 1$、$n > 1$、$n < 0$），驗證程式的正確性。

## 申論及開發報告

### 選擇遞迴的原因

在本程式中，使用遞迴來計算連加總和的主要原因如下：

Problem 1 — Ackermann’s Function
1. **函數本身定義就是遞迴形式**  
   本質上就是一個函數呼叫自身，因此最自然的實作方式就是遞迴

2. **容易對應數學定義**  
   用 if–else 結構即可完整反映三種情況，
可直觀展示「遞迴的結構思考」與「終止條件」的概念。

4. **遞迴的語意清楚**  
   在程式中，每次遞迴呼叫都代表一個「子問題的解」，而最終遞迴的返回結果會逐層相加，完成整體問題的求解。  
   這種設計簡化了邏輯，不需要額外變數來維護中間狀態。

透過遞迴實作 Sigma 計算，程式邏輯簡單且易於理解，特別適合展示遞迴的核心思想。然而，遞迴會因堆疊深度受到限制，當 $n$ 值過大時，應考慮使用迭代版本來避免 Stack Overflow 問題。
